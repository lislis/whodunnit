+++
author = "lislis"
title = "Reflection and documentation"
date = "2025-03-15"
description = "Reflection on the Wodunnit project on a meta level"
tags = [
    "documentation"
]
+++

Running through some template question.

> Explain which of the following categories are part of your results and how so:

Initally I named these categories:

**Software development, Algorithms, Research / Experimentation**

**Software development** is probably obvious, the heart of it is a Rust programm.

**Research/ Experimentation** is next. The interoperability of Prolog and Rust is pretty experimental, it's the biggest chunk of research that went into this project (next to learning Prolog).

**Algorithms** I would probably drop by now, because my logic is really not that fancy.


> Reflection of technical choices

**Why did you make the choice you made?**

The main motivating factor for technical choices was first and foremost learning Prolog and finding a cool sue case for it. So, Prolog in the tech stack was a given.

Next, I wanted to use Rust to for all other code. Mainly because I like the language and I really want to explore it more and get better at it. I hadn't yet attempted to make a full commandline programm in Rust (usually it's some type of game with graphics output or something web-related), so this seemed like a good learning opportunity.

**What worked well, what didn't?**

General development in Rust is just fun for me. Even looking into areas that I'm not super familiar with (like [making sys-calls](/blog/rust-prolog-interop/)) are usually well documented and more and more material is being published. It's a great time to learn Rust!

The biggest obstacle in everything was Prolog. That was somewhat to be expected since it was completely new to me. Everything just took a very long time. Plus, there is a limited amount of learning material out there and it's a bit dated. Even though there seem to be plenty of people using it? It's an interesting niche.

**What would you do differently next time?**

That's a good question. Probably nothing because it's exaclty what I wanted to explore.

> Reflection on your Minimal viable product and Best-case scenario plans

**What did you archive, what not and why?**

For my MVP I wanted the following things:

- Guaranteed interoperability between the Rust application/ game code and the Prolog interpreter
- A limited, Cluedo-like, setup should be generated by the game code and fed into the interprete
- The player interacts with the interpreter through raw Prolog queries
- Some game state is kept by the game code

Looking at these goals now, I almost hit them all. The interoperability kind of works in a very round-about hacky-way. But hey, at some point I thought I couldn't make it happen at all, so this is a great outcome, actually.  I have a limited Cluedo-like setup that is generated by game code and fed to the interpreter. Player interaction is in form of Prolog queries and there is a whee bit of game state boilerplate, ready to be fully implemented once interop is working.

> Challenge of your comfort zone

**What was new for you, and what did you learn?**

Prolog was new and I learned it. It was kind of the whole point. I still don't fully grasp the [Definite Clause Grammar](https://lpn.swi-prolog.org/lpnpage.php?pagetype=html&pageid=lpn-htmlch7) stuff, but it didn't seem too useful in my case either. Everything else I learned came from it, mostly Rust system call releated things.

**What was the most difficult for you?**

Learning Prolog. It was hard and really messed with my brain sometimes. I'm grateful for the exercises in *Learn Prolog Now!* and the solutions repository I found on GitHub (and [other resources](/blog/prolog-resources/)). Going from learning the basics to then thinking of designing game logic like I wanted it to work was a bit of a steep curve, but I think I did an okay job. The Prolog code is probably not the most efficient but at this point I don't care. It's alsop not that many lines of code, but it took quite a bit of time to get to this point.

Second to learning Prolog the most difficuelt thing was working on the Rust-Prolog-Interop, which I have now probably mentioned in every section of this website. It's the only part of this project that seems so obscure and niche that I feel like the first person on the internet doing it. Which is probably not true but still feels nice.

> Reflection on your original work plan with timeline

**Did you follow your plan and if not, why not?**

I only followed the plan in logical order, not in a factual week by week order. Why? Because I'm (still!, ha!) too optimistic about general life management and how much work I can get done on a given day. Bad estimates all around.

Actual delays in project work can only be blamed for so much, because ideally I'd schedule in more time for big, unfamiliar areas. Maybe I'll learn eventually.

Also, documentation work is not to be underestimated. Which I also always do. See this website and how all content was written waaaay to late. Maybe I'll learn that eventually, too.
